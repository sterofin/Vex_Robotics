#pragma config(Sensor, in1,    lineFollowerRIGHT, sensorLineFollower)
#pragma config(Sensor, in2,    lineFollowerCENTER, sensorLineFollower)
#pragma config(Sensor, in3,    lineFollowerLEFT, sensorLineFollower)
#pragma config(Sensor, dgtl1,  LeftDriveEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightDriveEnc,  sensorQuadEncoder)
#pragma config(Motor,  port4,           RightFrontDrive, tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port5,           LeftRearDrive, tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port6,           RightReadDrive, tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port7,           LeftFrontDrive, tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

// Global Variables here
bool resetDriveEncoders;		// this is used to determine if the drive encoders should be reset
float rDriveFactor;			// percentage of speed it is allowed to go
float lDriveFactor;			// percentage of speed it is allowed to go
bool rDirection = true; 		// true is forward
bool lDirection = true;			// true is forward

// Function Prototypes here
void DriveSetMotors (int LeftDriveSpeed, int RightDriveSpeed);
void DriveStraight( int LeftDriveSpeed, int RightDriveSpeed );
void DriveFactor( int LeftDriveSpeed , int RightDriveSpeed );
void FollowLine();

// Assign Pre_Autonomous functions here
void pre_auton()
{
}

// Assign autonomous functions here
task autonomous()
{
}

// Assign User Control here
task usercontrol()
{
	resetDriveEncoders = true;
	rDriveFactor = 0;
	lDriveFactor = 0;
	while (true)
	{
		if(vexRT[Btn6U])
		{
			FollowLine();
		}
		// if the values of the controllers is really close, the user is likely trying to drive straight
		// use encoders to make sure it can
		if( abs( vexRT[Ch3] - vexRT[Ch2] ) < 10 )
		{
			DriveFactor( vexRT[Ch3] , vexRT[Ch2] );
		}
		else
		{
			DriveFactor( vexRT[Ch3] , vexRT[Ch2] );
			resetDriveEncoders = true;
		}
	}
}

// This function will make the robot speed up progressively, not instantly 100% speed
void DriveFactor( int LeftDriveSpeed , int RightDriveSpeed )
{
	// if the joysticks are not touched, or in the dead zone, don't move the motors
	if( RightDriveSpeed < 10 && RightDriveSpeed > -10 && LeftDriveSpeed < 10 && LeftDriveSpeed > -10 )
	{
		DriveSetMotors(0,0);
		rDriveFactor = 0;
		lDriveFactor = 0;
	}
	else
	{
		if( RightDriveSpeed < 0 && rDirection ) // this means you went from forward to backwards
		{
			rDriveFactor = 0;
			rDirection = false;
		}
		else if( RightDriveSpeed > 0 && !rDirection ) // this means you went from backwards to forwards
		{
			rDriveFactor = 0;
			rDirection = true;
		}
		// slowly ramp up the speed, but don't allow to go past 1

		if( rDriveFactor < 1 && (RightDriveSpeed > 10 || RightDriveSpeed < -10) )
			rDriveFactor += 0.000525;
		else if( RightDriveSpeed > 10 || RightDriveSpeed < -10 )
			rDriveFactor = 1;
		else
			rDriveFactor = 0;

		if( LeftDriveSpeed < 0 && lDirection ) // this means you went from forward to backwards
		{
			lDriveFactor = 0;
			lDirection = false;
		}
		else if( LeftDriveSpeed > 0 && !lDirection ) // this means you went from backwards to forwards
		{
			lDriveFactor = 0;
			lDirection = true;
		}
		// slowly ramp up the speed, but don't allow to go past 1
		if( lDriveFactor < 1 && (LeftDriveSpeed > 10 || LeftDriveSpeed < -10))
			lDriveFactor += 0.000525;
		else if( LeftDriveSpeed > 10 || LeftDriveSpeed < -10 )
			lDriveFactor = 1;
		else
			lDriveFactor = 0;

		// if the directions are the same, make it drive straight, otherwise send the values to DriveSetMotors
		if( rDirection == lDirection )
			DriveStraight( (LeftDriveSpeed*lDriveFactor)/1.25, (RightDriveSpeed*rDriveFactor)/1.25 ) ;
		else
			DriveSetMotors ((LeftDriveSpeed*lDriveFactor)/1.25, (RightDriveSpeed*rDriveFactor)/1.25);

	}
}

// This function will make sure the robot drives straight
void DriveStraight(int LeftDriveSpeed, int RightDriveSpeed)
{
	// resetDriveEncoders is true, it will reset the drive encoders and gyro to 0 then set resetDriveEncoders to false
	// this makes sure it only resets when it starts to drive straight
	if( resetDriveEncoders )
	{
		SensorValue[LeftDriveEnc] = 0;
		SensorValue[RightDriveEnc] = 0;
		resetDriveEncoders = false;
	}
	int encoderError;
	int RightPercentSpeedChange;
	int LeftPercentSpeedChange;

	// this determine what directions the robot is moving, forward or backwards
	// The encoderError is flipped based on the direction it is driving
	if( LeftDriveSpeed > 0  )
	{
		encoderError =-1 * ( SensorValue[LeftDriveEnc] - SensorValue[RightDriveEnc] );
	}
	else
	{
		// remember its going backwards, thus both numbers a negative
		encoderError =-1 *( SensorValue[RightDriveEnc] - SensorValue[LeftDriveEnc] );
	}

	// if its driving forward
			// encoderError being positive - this means left is faster
					// Right speed up
					// Left slow down
			// encoderError being negative - this means right is faster
					// Right slow down
					// Left speed up
	// if its driving backwards
			// encoderError being positive - this means left is faster
					// Right speed up
					// Left slow down
			// encoderError being negative - this means right is faster
					// Right slow down
					// Left speed up
	if( encoderError > 0 )
	{
		// if error is small, change speeds by a small amount
		// else change speeds by a larger amount
		if( encoderError < 100 )
		{
			RightPercentSpeedChange = 	(int)(54 - (54 - 54*(encoderError/100.0)));
			LeftPercentSpeedChange = (int)(70 - (70 - 70*(encoderError/100.0)));
		}
		else
		{
			RightPercentSpeedChange = 	54;
			LeftPercentSpeedChange = 70;
		}
		// if driving forward - numbers are positive, thus subtract to slow, add to speed up
		// else driving backward - numbers are negative, thus add to slow, subtract to speed up
		if( LeftDriveSpeed > 0  )
			DriveSetMotors( LeftDriveSpeed - LeftPercentSpeedChange , RightDriveSpeed + RightPercentSpeedChange/2 );
		else
			DriveSetMotors( LeftDriveSpeed + LeftPercentSpeedChange , RightDriveSpeed - RightPercentSpeedChange/2 );
	}
	else
	{
		// if error is small, change speeds by a small amount
		// else change speeds by a larger amount
		if( encoderError > -100 )
		{
			RightPercentSpeedChange = 	(int)(70 - (70 + 70*(encoderError/100.0)));
			LeftPercentSpeedChange = (int)(54 - (54 + 54*(encoderError/100.0)));
		}
		else
		{
			RightPercentSpeedChange = 	70;
			LeftPercentSpeedChange = 54;
		}
		// if driving forward - numbers are positive, thus subtract to slow, add to speed up
		// else driving backward - numbers are negative, thus add to slow, subtract to speed up
		if( LeftDriveSpeed > 0  )
			DriveSetMotors( LeftDriveSpeed + LeftPercentSpeedChange/2 , RightDriveSpeed - RightPercentSpeedChange );
		else
			DriveSetMotors( LeftDriveSpeed - LeftPercentSpeedChange/2 , RightDriveSpeed + RightPercentSpeedChange/2 );
	}
}

// This function takes two parameters and assigns the drive motors to those speeds
void DriveSetMotors (int LeftDriveSpeed, int RightDriveSpeed)
{
	motor[LeftFrontDrive]  = LeftDriveSpeed  ;
	motor[RightFrontDrive] = RightDriveSpeed ;
	motor[RightReadDrive]  = RightDriveSpeed ;
	motor[LeftRearDrive]   = LeftDriveSpeed  ;
}

void FollowLine()
{
	int threshold = 700;
	while( true )
	{
		// crossroads hit as all 3 are seeing white
		if(SensorValue(lineFollowerCENTER) < threshold && SensorValue(lineFollowerRIGHT) < threshold && SensorValue(lineFollowerLEFT) < threshold )
    {

    }
		// if center is seeing white && other sensors are seeing dark
		else if(SensorValue(lineFollowerCENTER) < threshold && SensorValue(lineFollowerRIGHT) > threshold && SensorValue(lineFollowerLEFT) > threshold )
    {
      // go straight
    	DriveStraight( 40 , 40 );
    }
    // if center is seeing white and right is seeing white and left is seeing dark
		else if( (SensorValue(lineFollowerCENTER) < threshold && SensorValue(lineFollowerRIGHT) < threshold && SensorValue(lineFollowerLEFT) > threshold )
		{
			// this means right needs to speed up and left slow down
			DriveSetMotors( 20 , 40 );
		}
		// if center is seeing white and left is seeing white and right is seeing dark
		else if( (SensorValue(lineFollowerCENTER) < threshold && SensorValue(lineFollowerRIGHT) > threshold && SensorValue(lineFollowerLEFT) < threshold )
		{
			// this means left needs to speed up and right slow down
			DriveSetMotors( 40 , 20 );
		}
		// left is seeing white and no one else
		else if( SensorValue(lineFollowerCENTER) > threshold && SensorValue(lineFollowerRIGHT) > threshold && SensorValue(lineFollowerLEFT) < threshold )
		{
			// this means right speeds up, left stop
			DriveSetMotors( 0 , 40 );
		}
		// right is seeing white and no one else
		else if( SensorValue(lineFollowerCENTER) > threshold && SensorValue(lineFollowerRIGHT) < threshold && SensorValue(lineFollowerLEFT) > threshold )
		{
			// this means left speeds up, right stop
			DriveSetMotors( 40 , 0 );
		}
		else
		{
			DriveSetMotors( 0 , 0 );
		}


  }
}
